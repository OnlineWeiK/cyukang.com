<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
	<channel>
		<title></title>
		<description></description>
		<link>http://cyukang.com</link>
		
			<item>
				<title>一些包管理命令</title>
				<description>
&lt;p&gt;包管理器是Linux上一个经常用的东西，我觉得下面这几个命令是非常有用的，便于查询包的状态，或者搜索我该安装哪些包。&lt;/p&gt;

&lt;h2 id=&quot;apt-cache&quot;&gt;apt-cache&lt;/h2&gt;

&lt;p&gt;用来根据名字查询软件包，比如apt-cache search vim查询vim相关的。&lt;/p&gt;

&lt;h2 id=&quot;apt-file&quot;&gt;apt-file&lt;/h2&gt;

&lt;p&gt;用来根据某个文件查询软件包，这在编译程序的时候非常有用，可以通过所需要的头文件去查询要安装的东西，可以避免去Google了。注意使用之前需要安装并update。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install apt-file
sudo apt-file update
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;比如我在编译某个软件的时候找不到&amp;lt;readline/readline.h&amp;gt;，使用下面的命令来查询一下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-file readline.h
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果中有这么一行，那么我就知道继续安装libreadline5-dev库就行了。&lt;/p&gt;

&lt;h2 id=&quot;dpkg&quot;&gt;dpkg&lt;/h2&gt;

&lt;p&gt;apt是基于dpkg开发的，dpkg是更古老更底层的一套工具，Debian系统管理器的基础。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dpkg -l 列出所有已经安装的包
dpkg -s vim 列出包vim的状态
dpkg -L vim 列出本地所有vim相关联系的文件
dpkg -S vim 搜索所属包的内容
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;brew&quot;&gt;brew&lt;/h2&gt;

&lt;p&gt;Mac下推荐Brew来替代apt，大部分的开源包都有对应的地址源了。我没使用过MacPorts，无法比较这两套的差别。
不过我个人很喜欢的一点是brew所有安装的东西都在&lt;code&gt;brew -prefix&lt;/code&gt;/Cellar这个统一目录下，&lt;/p&gt;

&lt;p&gt;brew相关的命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;brew list   — 列出已安装的软件
brew update — 更新Homebrew
brew home   — 用浏览器打开
brew info   — 显示软件内容信息
brew deps   - 显示包依赖
&lt;/code&gt;&lt;/pre&gt;

</description>
				<published>2013-04-17 00:00:00 +0800</published>
				<link>http://cyukang.com/2013/04/17/apt-usage.html</link>
			</item>
		
			<item>
				<title>巧妙的XOR Link List</title>
				<description>
&lt;p&gt;XOR Link List, 只用一个附加的变量来实现双向链表。首先xor本身是个稍微有点难理解的操作。xor有下面的一些特性:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;A ^ 0 = A&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;A ^ A = 0&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;A ^ B = B ^ A&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;(A ^ B) ^ A = B&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;(B ^ A) ^ B = A&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;注意最后两条，这是XOR Link List的关键，这也是通过xor操作来实现swap的关键。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xorSwap&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
         &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;^=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
         &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;^=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
         &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;^=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
     &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里注意需要判断x!=y，否则如果传入的是相同的指针，最后所指向的变量被设置为0了。&lt;/p&gt;

&lt;p&gt;通过最后两条联想到双向链表中的两个指针的实现，一般如下图所示：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;      &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;       &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt;         &lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;         &lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;         &lt;span class=&quot;n&quot;&gt;E&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
               &lt;span class=&quot;err&quot;&gt;–&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;–&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;  &lt;span class=&quot;err&quot;&gt;–&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;  &lt;span class=&quot;err&quot;&gt;–&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;        
               &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;–&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;–&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;–&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;–&lt;/span&gt;        
 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果把next和prev用一个变量替换还能实现前向和后向遍历，那就节省了一个变量的空间。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt;         &lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;         &lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;         &lt;span class=&quot;n&quot;&gt;E&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;–&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;⊕&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;&amp;lt;-&amp;gt;&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;⊕&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;&amp;lt;-&amp;gt;&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;⊕&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;E&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;&amp;lt;-&amp;gt;&lt;/span&gt;
 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;比如当前在B节点，其pointer变量为A⊕C，如果前面的A地址保存下来然后做运算(A⊕C)⊕A -&amp;gt; C，这样就得到下一个节点指针，反向遍历同样如此。当然其缺点是逻辑复杂了，删除其中的某一个节点也不方便(删除头和尾要好点)，遍历的时候需要保存上一个节点。这样看来为了省一点点空间这样实现似乎有点不值，在大部分情况下这样的一个pointer的节省并没什么用，不过这其中的细节有趣、巧妙。&lt;/p&gt;

&lt;p&gt;同样上面的xorSwap&lt;a href=&quot;http://stackoverflow.com/questions/249423/how-does-xor-variable-swapping-work&quot;&gt;对于现代的CPU来说也没什么优化&lt;/a&gt;，这样的代码只是更加不便于编译器来实现指令级别的优化。这种类型trick的东西还是要避免使用才好。&lt;/p&gt;

&lt;p&gt;自己稍微写了一下，代码在&lt;a href=&quot;https://gist.github.com/chenyukang/5364515&quot;&gt;这个Gist&lt;/a&gt;。&lt;/p&gt;
</description>
				<published>2013-04-11 00:00:00 +0800</published>
				<link>http://cyukang.com/2013/04/11/xor_link_list.html</link>
			</item>
		
			<item>
				<title>Jekyll使用MathJax来显示数学式</title>
				<description>
&lt;p&gt;使用Jekyll写作文章的时候有可能需要内嵌一些数学公式, &lt;a href=&quot;http://www.mathjax.org/&quot;&gt;MathJax&lt;/a&gt;就是用来干这个的，试用了一下感觉非常方便。步骤如下:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;修改html头部。&lt;/p&gt;

    &lt;p&gt;在每个页面开头加上这么一句，在Jekyll下可以通过修改default.html加上。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;script&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;text/javascript&amp;quot;&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;script&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;本地安装kramdown。&lt;/p&gt;

    &lt;p&gt;因为rdiscount和默认的markdown在解析带公式文件的时候都会出现&lt;a href=&quot;http://stackoverflow.com/questions/10987992/using-mathjax-with-jekyll&quot;&gt;一些问题&lt;/a&gt;，所以最简单办法还是安装kramdown。
 ` $ gem install kramdown`&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;修改_config.yml，把markdown选项修改为:&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;markdown: kramdown&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;然后在发布的时候就可以使用&lt;code&gt;$$&lt;/code&gt;来把需要显示的数学式子扩起来。像这样：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$$a^2 + b^2 = c^2$$&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;发布出来就是漂亮的公式了。
    &lt;script type=&quot;math/tex&quot;&gt;a^2 + b^2 = c^2&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;一些更酷的例子：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt; J_\alpha(x) = \sum\limits_{m=0}^\infty \frac{(-1)^m}{m! \, \Gamma(m + \alpha + 1)}{\left({\frac{x}{2}}\right)}^{2 m + \alpha} &lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt; \frac{1}{\Bigl(\sqrt{\phi \sqrt{5}}-\phi\Bigr) e^{\frac25 \pi}} =
1+\frac{e^{-2\pi}} {1+\frac{e^{-4\pi}} {1+\frac{e^{-6\pi}}
{1+\frac{e^{-8\pi}} {1+\ldots} } } } &lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt; \left( \sum_{k=1}^n a_k b_k \right)^2 \leq \left( \sum_{k=1}^n a_k^2 \right) \left( \sum_{k=1}^n b_k^2 \right)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt; 
\begin{aligned}
\nabla \times \vec{\mathbf{B}} -\, \frac1c\, \frac{\partial\vec{\mathbf{E}}}{\partial t} = \frac{4\pi}{c}\vec{\mathbf{j}} \\ \nabla \cdot \vec{\mathbf{E}} = 4 \pi \rho \\
\nabla \times \vec{\mathbf{E}}\, +\, \frac1c\, \frac{\partial\vec{\mathbf{B}}}{\partial t} = \vec{\mathbf{0}} \\
\nabla \cdot \vec{\mathbf{B}} = 0 \end{aligned}
&lt;/script&gt;

&lt;p&gt;不过我可能永远用不到这么复杂的表达式 :). &lt;/p&gt;

&lt;p&gt;另外今天找了一个&lt;a href=&quot;http://jblevins.org/projects/markdown-mode/&quot;&gt;markdown-mode.el&lt;/a&gt;，在Emacs下编辑Markdown文件又方便了不少。
   Mac下的Markdown编辑器&lt;a href=&quot;http://mouapp.com/&quot;&gt;Mou&lt;/a&gt;也是非常不错的。&lt;/p&gt;

</description>
				<published>2013-03-03 00:00:00 +0800</published>
				<link>http://cyukang.com/2013/03/03/try-mathjax.html</link>
			</item>
		
			<item>
				<title>读bootstrap scheme</title>
				<description>
&lt;p&gt;&lt;img src=&quot;/images/scheme_car_cdr.png&quot; alt=&quot;scheme-car-cdr&quot; class=&quot;img-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;For a List in Lisp, Car is the First, Cdr is the Rest, and Lisp means List-Proccessing.&lt;/p&gt;

&lt;p&gt;前段时间偶然在网上看到这个&lt;a href=&quot;https://github.com/petermichaux/bootstrap-scheme&quot;&gt;bootstrap scheme这个开源程序&lt;/a&gt;，读来简洁明了，十分有趣。我对scheme有一点了解，毕竟以前看过一段时间SICP，自己做练习的代码也是scheme写的。scheme本身属于Lisp方言，语法也极其简单，学习起来非常快的。&lt;/p&gt;

&lt;p&gt;看看这个简单的scheme实现，不禁再次感叹递归的优美。Lisp这样的语言直接使用语法树结构来表示程序，不仅使得表示出来的程序异常简洁，就是用C语言来实现这种语言的解释器代码也看起来非常优美。在这里区区2000行的C语言代码，当然没有完整地实现scheme所有的内容，甚至只支持了整数。但是包含scheme的基本语法层面的东西，还有lambda。抛开实现的效率不说，递归是易于编写和理解代码的一种方式，这里语法是递归的，parser是递归的，eval也是递归的。在这里所有的东西都是object，没有显示的列表结构，但是嵌套的pair里蕴含着列表和树的关系。在parse阶段建立好一个以object为基本元素的树结构，做eval的时候顺着往下走就是了。&lt;/p&gt;

&lt;p&gt;推荐对语言实现感兴趣的同学阅读一下这个代码，如果对scheme不了解也没关系，用一个小时看几个scheme程序基本就了解了。再看这个解释器，你就懂了代码是如何被运行的。&lt;/p&gt;

&lt;p&gt;参考&lt;a href=&quot;http://peter.michaux.ca/articles/scheme-from-scratch-introduction&quot;&gt;scheme-from-scratch-introduction&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;图片来自&lt;a href=&quot;http://www.cs.utah.edu/~draperg/cartoons/&quot;&gt;Draperg’s cartoons&lt;/a&gt;&lt;/p&gt;
</description>
				<published>2013-02-15 00:00:00 +0800</published>
				<link>http://cyukang.com/2013/02/15/reading-bootstrap-scheme.html</link>
			</item>
		
			<item>
				<title>Emacs会说话</title>
				<description>
&lt;p&gt;出来工作之前我从来没认真考虑过我的英语口语问题，大学时候的四级口语考试C级也没让我意识到自己的发音比较烂。学了好多年哑巴英语，又因为本人生性有点害羞经常不好意思开口说英语，悲剧早就注定。其实我的英语阅读能力还是可以的，不过工作之后同事们都嘲笑我口语听起来像印度人，据说发音极其古怪。&lt;/p&gt;

&lt;p&gt;在Mac下有一个叫做say的命令行程序，我有时候会用来听单词单词发音。这个程序加上-f参数也可以用来朗读整个文件。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; say hello wrold
 say -f demo.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;前几天突然觉得如果写个Emacs Minor Mode，能在边写单词的时候Emacs就把你写的朗读一遍就好了，Emacs号称能煮咖啡，这点小事当然不在话下。其实除了在公司我也很少写英文，不过这个想法看起来比较好玩，于是动手做了一下。预想的基本功能是实现了，我把它叫做EmacSay-mode，意为在Emacs+Mac+Say下实现的，所以这东西可能不能在Linux下运行。&lt;/p&gt;

&lt;p&gt;这也是我第一次学着写一个minor mode，实现起来也很简单。整个不到100行elisp代码。&lt;/p&gt;

&lt;p&gt;基本思路就是如果当前输入的字符是空白(或者其他非字母字符)，寻找前面一个字符串，格式化成一个命令行，用start-process或者shell-command来调用。
注意start-process会fork出来一个子进程来执行命令，在书写过程中最好还是使用start-process来调用命令，因为say可能要待个一两秒才返回，如果使用shell-command来调用会造成输入有迟钝的感觉。&lt;/p&gt;

&lt;p&gt;绑定的快捷键有这些，其中eamcsay-say-buffer是用来朗读当前的整个buffer，如果你想在其中中断朗读使用emacsay-say-stop。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;cl&quot;&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;defvar&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;emacsay-mode-map&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;&amp;quot;Keymap for emacsay minor mode&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;unless&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;emacsay-mode-map&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;map&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;make-sparse-keymap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;define-key&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;map&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;\C-cs&amp;quot;&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;&amp;#39;emacsay-say-current-string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;define-key&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;map&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;\C-cp&amp;quot;&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;&amp;#39;emacsay-say-buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;define-key&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;map&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;\C-ct&amp;quot;&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;&amp;#39;emacsay-say-stop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;setq&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;emacsay-mode-map&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;还可以有一些小的改进，比如阅读时候闪烁单词，或者say声音的选择等等。&lt;/p&gt;

&lt;p&gt;所有代码在GitHub: &lt;a href=&quot;https://github.com/chenyukang/emacSay&quot;&gt;emacSay-mode&lt;/a&gt;。 &lt;/p&gt;

</description>
				<published>2013-01-27 00:00:00 +0800</published>
				<link>http://cyukang.com/2013/01/27/emacs-speaking-now.html</link>
			</item>
		
			<item>
				<title>迟到的POJ 500</title>
				<description>
&lt;p&gt;我发现自己有了很重的拖延症，一个表现就是在2011年3月定下的目标&lt;a href=&quot;http://cyukang.com/2011/03/27/fuckpaper.html&quot;&gt;POJ 500&lt;/a&gt;最近才完成。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://poj.org/userstatus?user_id=chenyukang&quot;&gt;这一页500道题&lt;/a&gt;耗费了我很多时间和精力，同样也带给了我很多知识和乐趣。&lt;/p&gt;

&lt;p&gt;当然工作后毕竟还是没有学校的时间充足了，现在还花时间来做题似乎显得很悠闲，这500题最后十个是在元旦的几天假期里完成的。我是从2010年的4月份开始在Poj上做题，那天偶然发现自己原来2006年还注册过账号，于是做了两题试试，没想到后面就竟然沉迷其中，一直到自己从学校毕业出来。这两年强度还不算大，平时还是要在实验室做做项目的。我没参加过专业队的训练，不过参加过一次学校的比赛，和王骆驼两个人一个下午做出来五道，比较悲剧的是差一道没进决赛。不过当时还是挺欣慰的，毕竟自己还是不算专业选手啊。这一年多静下心来写程序收获很多，因为体会到了写程序的乐趣，有时候在睡觉的时候脑袋也在不知不觉地想问题。有时候我选择按不同的数据结构或者算法思想来选题做，有时候就在线上泡着看排我前面的人在做什么，然后自己也跟着做，这真写的是寂寞啊。不过现在回想起来这一两年算是最自由、最充实的写程序的日子了。&lt;/p&gt;

&lt;p&gt;像ACM题这些东西最好还是大学开始接触，在开始学习基本算法和数据结构的时候就开始进行训练是最好的。当然如果大学能进专业队训练就更不错了，如果只是业余拿来练练手也是大有裨益的。也许我们做不到专业队哪些人写代码就像秀肌肉一样，体会到其中的乐趣就够了。在我开始做POJ之前我还是对算法充满了恐惧，感觉太高深。经过这些渐进的学习和训练，现在至少说有点入门的感受，面对一个问题多多少少会有一些思路和想法。也许平时项目和工作并没用到多少纯粹的算法部分，只是这有了这基本功还是能让你迅速上手其他东西。&lt;/p&gt;

&lt;p&gt;《黑客和画家》里写到学习写程序和学习绘画的诸多相同点，这都是一门技能，除了多写、多看、多思考之外没有其他捷径可走。折腾多了自然就会有一点感觉。学习绘画的另外一个途径就是观摩经典的杰作，同样对应地看开源项目是另外一个很好的学习编程的途径。&lt;/p&gt;

&lt;p&gt;幸好GitHub又被解封了。&lt;/p&gt;
</description>
				<published>2013-01-22 00:00:00 +0800</published>
				<link>http://cyukang.com/2013/01/22/poj-500.html</link>
			</item>
		
			<item>
				<title>获取挂掉程序的栈信息</title>
				<description>
&lt;p&gt;在程序挂掉的时候最好还是留点有用的遗言，特别是对于一些比较难重现的Bug，也许这些信息会成为解决问题的关键。&lt;/p&gt;

&lt;p&gt;下面这个技巧可以让程挂掉的时候打印出来栈信息。这个办法来自&lt;a href=&quot;http://neugierig.org/software/blog/2012/06/backtraces.html&quot;&gt;这里&lt;/a&gt;, 我觉得把SIGABRT、SIGBUS信号加进去也挺好的，在此做了点修改。曾经尝也试过glibc的backtrace函数，，但是给的信息不全(没有行号)，对此做得最好的还是gdb。 在终端可以用gdb获取某个进程的当前栈：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gdb -p 5595 -batch -ex bt
0xb7fb4410 in __kernel_vsyscall ()
#0  0xb7fb4410 in __kernel_vsyscall ()
#1  0xb7dc2d50 in nanosleep () from /lib/tls/i686/cmov/libc.so.6
#2  0xb7dc2b87 in sleep () from /lib/tls/i686/cmov/libc.so.6
#3  0x0804874f in main () at print_stack.cc:64
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么一个好的办法就是在程序开始的时候设置好信号，绑定SIGSEGV和SIGABRT到DumpBackTrace()函数，DumpBackTrace函数fork出来一个新进程，运行上面的命令来获取调用栈。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;signal.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;sys/wait.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;unistd.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;assert.h&amp;gt;&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DumpBacktrace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;pid_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dying_pid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getpid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;pid_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;child_pid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fork&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;child_pid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;perror&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;fork() while collecting backtrace:&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;child_pid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1024&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;sprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;gdb -p %d -batch -ex bt 2&amp;gt;/dev/null | &amp;quot;&lt;/span&gt;
                &lt;span class=&quot;s&quot;&gt;&amp;quot;sed &amp;#39;0,/&amp;lt;signal handler/d&amp;#39;&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dying_pid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;sh&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;-c&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;execve&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;/bin/sh&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;_exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;waitpid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;child_pid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;_exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BacktraceOnSegv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sigaction&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;action&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{};&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;action&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sa_handler&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DumpBacktrace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sigaction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SIGSEGV&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;action&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;perror&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;sigaction(SEGV)&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sigaction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SIGABRT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;action&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;perror&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;sigaction(SEGV)&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//assert(0);&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;BacktraceOnSegv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;另外前段时间看到这篇文章&lt;a href=&quot;http://www.runswift.ly/solving-bugs.html&quot;&gt;Solving vs. Fixing&lt;/a&gt;写得不错，在面对一个bug的时候，先不要急于立马上gdb调试，根据现有的信息好好思考为什么会出现这个情况。
Reddit上的一个得分最高的回复：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; The ability to reason about code is probably the most important skill. 
 But it is sadly rare, and doesn't seem to be taught much, if at all.
 Some things are simple, others take some more thought:

 * Under what conditions will this branch get taken?
 * What could cause this API to fail?
 * Are all these parameters even valid?
 * What sequence of events could lead to this situation?
 * What assumptions does this code make?
 * What side-effects does this code have?
 * What contract is this code making (or breaking)?
 
 The most talented engineer I know, when presented with a bug, does nothing but 
 read the code and think about the code and how it could fail. 
 Most of the time,  he just figures it out in his head and fixes it. 
 Sometimes he will insert some strategic printfs and narrow it down like that. 
 I don't think I have ever seen him use a debugger, 
 even on the most complex of problems.
&lt;/code&gt;&lt;/pre&gt;
</description>
				<published>2013-01-04 00:00:00 +0800</published>
				<link>http://cyukang.com/2013/01/04/print-stack-before-exiting.html</link>
			</item>
		
			<item>
				<title>Browser objs and class hierarchy  in Ruby</title>
				<description>
&lt;p&gt;Ruby里一切都是对象，如何能看到Ruby内建的对象模型呢。这里有个小程序来查看Ruby内部构建好的的对象和类。ObjectSpace可以迭代所有对象。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;    &lt;span class=&quot;n&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;no&quot;&gt;ObjectSpace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;each_object&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

   &lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;each&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
     &lt;span class=&quot;nb&quot;&gt;puts&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
   
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;下面这段就能根据对象，取得class对象，建立起类的继承图。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;  &lt;span class=&quot;c1&quot;&gt;# Creates or updates a klass_tree.&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;# When updating no classes or objects are removed&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;object_browser&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;classtree&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;ClassTreeNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;Kernel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;no&quot;&gt;ObjectSpace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;each_object&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;classnode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;classtree&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ancestors&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;reverse&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;\&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;inject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;classtree&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;classnode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;klass&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;classnode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;add_class&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;klass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;add_object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;classtree&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;use this command to get image:&lt;/p&gt;

&lt;p&gt;$ruby prog.rb &amp;gt; class.dot; dot -Tpng class.dot -o class.png&lt;/p&gt;

&lt;p&gt;结果看起来像这样，所有对象都画出来比较多，看大图还稍微能看到一些。完整的代码在&lt;a href=&quot;https://gist.github.com/4380597&quot;&gt;这里&lt;/a&gt;。
&lt;img src=&quot;/images/class.png&quot; alt=&quot;class in Ruby&quot; class=&quot;img-center&quot; /&gt;
&lt;img src=&quot;/images/objs.png&quot; alt=&quot;class in Ruby&quot; class=&quot;img-center&quot; /&gt;&lt;/p&gt;
</description>
				<published>2012-12-26 00:00:00 +0800</published>
				<link>http://cyukang.com/2012/12/26/browser-objs-in-ruby.html</link>
			</item>
		
			<item>
				<title>Clang is Making Emacs Smarter</title>
				<description>
&lt;p&gt;在Emacs下自动补全总是个问题，对于同一个buffer内的基于symbol补全auto-complete-mode做得非常好了，但是因为没有进行代码的分析，所以像结构体的成员变量或者类的成员函数的补全是不可能的。当然你可能试过这个号称最智能的&lt;a href=&quot;http://cx4a.org/software/gccsense/&quot;&gt;GCCSence&lt;/a&gt;,但是我觉得这个东西够复杂的，在使用之前还需要用户手动运行一个命令来用Gcc处理一遍，它还会把一些东西放在sqlite数据库里面。这大概是因为Gcc不编译做静态分析工具造成的，在&lt;a href=&quot;http://lwn.net/Articles/493599/&quot;&gt;这里&lt;/a&gt;、&lt;a href=&quot;http://lwn.net/Articles/493627/&quot;&gt;这里&lt;/a&gt;、&lt;a href=&quot;http://lwn.net/Articles/493630/&quot;&gt;这里&lt;/a&gt;有讨论，Google的一个静态分析的项目从Gcc迁移到LLVM，重点是这:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;The gcc version has been difficult to support and maintain, due mainly to the fact that the GIMPLE intermediate language was never designed for static analysis. The abstract syntax tree provided by Clang is an easier data structure to work with for front-end analyses of this kind.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个thread挺好玩的，后面变成了一大群人争论functional programming和Imperative Programming。这篇&lt;a href=&quot;http://fpcomplete.com/the-downfall-of-imperative-programming/&quot;&gt;The Downfall of Imperative Programming&lt;/a&gt;再好好看看。&lt;/p&gt;

&lt;p&gt;回到正题，我最近切换到Mac下。因为在Mac OS X下编译器变成了Clang， Clang是基于LLVM的。LLVM对于分析代码是有比较方便的支持，所以基于LLVM有各种分析源程序的工具了，Xcode下的一些辅助开发的工具还是很舒服的。前些天突然想到那么会不会有个东西来作为Emacs的自动补全的后端，一搜果然有了这个&lt;a href=&quot;https://github.com/mikeandmore/auto-complete-clang&quot;&gt;auto-complete-clang&lt;/a&gt;，使用了一下非常的方便。其实看看其代码是在后面调用Clang的，比如在main.cc源文件里面写一些代码:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    &lt;span class=&quot;cp&quot;&gt;#include &amp;lt;string&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;cp&quot;&gt;#include &amp;lt;vector&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Demo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
    
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Demo&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;demo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;demo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;结果还是非常精准的，不想截图了。后端运行的命令其实是:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;    cmd: clang -cc1 main.cc -fsyntax-only -code-completion-at main.cc:18:10
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;所得到的结果是:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;    COMPLETION: Demo : Demo::
    COMPLETION: &lt;span class=&quot;nv&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; : &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;c&quot;&gt;#Demo &amp;amp;#]operator=(&amp;lt;#const Demo &amp;amp;#&amp;gt;)&lt;/span&gt;
    COMPLETION: print : &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;c&quot;&gt;#void#]print()&lt;/span&gt;
    COMPLETION: &lt;span class=&quot;nb&quot;&gt;test&lt;/span&gt; : &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;c&quot;&gt;#void#]test()&lt;/span&gt;
    COMPLETION: value : &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;c&quot;&gt;#int#]value&lt;/span&gt;
    COMPLETION: ~Demo : &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;c&quot;&gt;#void#]~Demo()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;auto-complete-clang做的事情就是把这个结果再展示出来，其实这条命令也做了语法检查的，所以加上一个语法检查的功能应该也是可以的。一搜果然还是有了，看这个&lt;a href=&quot;http://duncan.mac-vicar.com/2011/08/30/realtime-syntax-checking-with-emacs/&quot;&gt;Realtime syntax checking with emacs&lt;/a&gt;，需要翻墙，不过代码在&lt;a href=&quot;https://github.com/dmacvicar/duncan-emacs-setup/tree/master/site-lisp&quot;&gt;Github上&lt;/a&gt;。其实其后端运行的命令是：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;   cmd: clang  -fsyntax-only -fno-exceptions main.cc
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;最近用这个插件，基本代码都会是一遍编译通过啊，哈哈。Clang错误提示也人性化一点，比如在Xcode下会提示你想的是不是”XXX”之类的。&lt;/p&gt;

</description>
				<published>2012-12-16 00:00:00 +0800</published>
				<link>http://cyukang.com/2012/12/16/use-clang-autocomplete-mode.html</link>
			</item>
		
			<item>
				<title>Have a try on Ninja</title>
				<description>
&lt;p&gt;&lt;img src=&quot;/images/compiling.png&quot; alt=&quot;My code is compiling&quot; class=&quot;img-center&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;ninja&quot;&gt;什么是Ninja&lt;/h2&gt;
&lt;p&gt;在Unix/Linux下通常使用Makefile来控制代码的编译，但是Makefile对于比较大的项目有时候会比较慢，看看上面那副漫画，代码在编译都变成了程序员放松的借口了。所以这个Google的程序员在开发Chrome的时候因为忍受不了Makefile的速度，自己重新开发出来一套新的控制编译的工具叫作&lt;a href=&quot;https://github.com/martine/ninja&quot;&gt;Ninja&lt;/a&gt;，Ninja相对于Makefile这套工具更注重于编译速度。除了Chrome现在还有一些其他的比较大的项目也在开始使用Ninja，比如LLVM。我试用了一下感觉还是不错，比如编译Cmake时间大概是原来的1/4。Ninja试用C++实现，&lt;a href=&quot;http://martine.github.com/ninja/manual.html&quot;&gt;其支持的语法非常简单&lt;/a&gt;，作者在这里说明了为了控制复杂度。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;代码如何编译&lt;/h2&gt;
&lt;p&gt;其实对于C/C++和很多其他程序的编译都是一个道理，就是把一些源代码文件编译成目标文件，或者有的目标文件再编译到一个库里，然后再链接起来。所以Ninja的配置文件分为两个部分，rule和文件依赖关系。看个简单的例子:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;    &lt;span class=&quot;nv&quot;&gt;cc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;gcc
    &lt;span class=&quot;nv&quot;&gt;cflags&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; -g -c
    
    rule cc
         &lt;span class=&quot;nb&quot;&gt;command&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;	&lt;span class=&quot;nv&quot;&gt;$cc&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$cflags&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$in&lt;/span&gt; -o &lt;span class=&quot;nv&quot;&gt;$out&lt;/span&gt;
    
    rule link
         &lt;span class=&quot;nb&quot;&gt;command&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$cc&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$in&lt;/span&gt; -o &lt;span class=&quot;nv&quot;&gt;$out&lt;/span&gt;
    
    rule cleanup
         &lt;span class=&quot;nb&quot;&gt;command&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; rm -rf *.exe *.o
    
    build func.o           : cc func.c
    build main.o           : cc main.c
    
    build app.exe            : link main.o func.o
    
    build all:  phony &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; app.exe
    build clean: cleanup 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;非常易懂，编译的可执行未见叫做app.exe, 其中有三条rule: cc, link, cleanup。看看这个官方的试用手册，还有一些附加参数可以加在rule的下面，比如description用来在编译的时候显示出来。Ninja还有个比较好玩的功能就是Ninja -t graph all命令，这可以用来生成编译时候的依赖关系，可以用dot来生成图片等。Ninja的实现也可以大概推测到，根据用户给的依赖关系图，&lt;em&gt;并行&lt;/em&gt; 地编译各个文件。&lt;/p&gt;

&lt;p&gt;使用Ninja的一个问题就是需要生成这个build.ninja文件，对于大型项目来说这样一条一条地写配置文件是不可能的。幸好我们可以使用Cmake来生成这个配置文件，Cmake对应的是automake这样的东西。在&lt;a href=&quot;http://www.kitware.com/news/home/browse/CMake?2012_11_07&amp;amp;CMake+2.8.10+Just+Released&quot;&gt;Cmake的最新版本&lt;/a&gt;中已经支持参数Camke -G Ninja，Cmake会根据用户给定的CMakeLists.txt来生成build.ninja文件。而CmakeLists文件相对来说要简单一些，只要写清楚编译的可执行文件的名字，和其依赖的包含main函数的源文件。把我的&lt;a href=&quot;https://github.com/chenyukang/Maze&quot;&gt;迷宫小项目&lt;/a&gt;来举个例子,在项目文件夹下写配置文件CMakeLists.txt:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;    
cmake_minimum_required&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;VERSION 2.8&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
project &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;Maze&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

add_library&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;maze A_star.cpp Algorithm.cpp DFS_L.cpp DFS_R.cpp DisjSets.cpp Maze.cpp&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

add_executable&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;Maze.exe main.cpp&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
target_link_libraries&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;Maze.exe maze&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;add_library写明了生成一个叫做maze.a的库文件，然后和main.cpp编译出来的main.o生成可执行文件，写好CmakeList.txt后运行Cmake -G Ninja, 然后运行ninja all就能编译这个工程。具体的Cmake语法参考&lt;a href=&quot;http://www.cmake.org/cmake/help/cmake_tutorial.html&quot;&gt;这里&lt;/a&gt;，对于不少项目来说Cmake已经足够使用，只是我觉得Cmake还是稍微复杂了一点。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;我这样来使用&lt;/h2&gt;

&lt;p&gt;整个Ninja是使用C++写的开源项目，如果我们想增加一些自己的feature可以hack一下，不过作者估计不会接受增加语法支持的patch。我准备做一个小的hack来自动分析我当前的源码，自动生成build.ninja文件，不要求处理所有的复杂情况，只是分析.cc和.c，自动检测main函数文件。最后用户只用配置链接参数就可以了。我觉得这样用起来就非常方便了，待完成中，顺便看看Ninja的内部实现。&lt;/p&gt;
</description>
				<published>2012-12-13 00:00:00 +0800</published>
				<link>http://cyukang.com/2012/12/13/have-a-try-for-ninja.html</link>
			</item>
		
	</channel>
</rss>
