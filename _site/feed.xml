<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
	<channel>
		<title></title>
		<description></description>
		<link>http://cyukang.com</link>
		
			<item>
				<title>Leanring Ruby with Ruby Warrior</title>
				<description>
&lt;p&gt;Ruby上总有好玩的东西，偶然看到这个&lt;a href=&quot;https://github.com/ryanb/ruby-warrior&quot;&gt;RubyWarrior&lt;/a&gt;，玩了一把感觉还有些意思。这个有些像我原来介绍的&lt;a href=&quot;http://cyukang.com/2012/11/22/ruby-robot-ai.html&quot;&gt;RubyRobot&lt;/a&gt;,
不过更像之前的&lt;a href=&quot;http://cyukang.com/2011/07/22/wumpus-and-2.html&quot;&gt;Wumpus&lt;/a&gt;，看来我对这种游戏有些兴趣。&lt;/p&gt;

&lt;p&gt;Ruby新手边玩边熟悉了语言。需要代码的可以clone下来看看，如果只是玩可以gem装上，然后运行rubywarrior就开始练级了。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;gem install rubywarrior&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我现在只是完成了初学者模式，这里的AI还比较简单，主要实现一个函数就行了。分为两种模式，第一种只用对付当前的场景，第二种为epic(史诗?)模式，要从1~9连续闯关。&lt;/p&gt;

&lt;p&gt;我的平均成绩是C，所有级的代码放在&lt;a href=&quot;https://github.com/chenyukang/rubywarrior&quot;&gt;Github上&lt;/a&gt;了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
Level Score: 27
Time Bonus: 18
Level Grade: F
Total Score: 374 + 45 = 419
Your average grade for this tower is: C

Level 1: S
Level 2: C
Level 3: B
Level 4: B
Level 5: D
Level 6: F
Level 7: B
Level 8: F
Level 9: F
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;

&lt;p&gt;中级模式是二维的地图，所以更有挑战。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/Spooner/ruby_armor&quot;&gt;这里&lt;/a&gt;有一个前端，不过我还没用过。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/Sujimichi/ruby_warrior_NN_solution&quot;&gt;这还有人用神经网络的方法来做的&lt;/a&gt;，可以学习一下，:)。&lt;/p&gt;
</description>
				<published>2013-07-14 00:00:00 +0800</published>
				<link>http://cyukang.com/2013/07/14/ruby-warrior.html</link>
			</item>
		
			<item>
				<title>Metaprogramming Ruby</title>
				<description>
&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Meteprogramming is writing code that writes code&lt;/li&gt;
  &lt;li&gt;鬼城和集市，很多语言的运行环境在执行的时候已经固定，一片死寂。而支持Metaprogramming的语言的执行环境是充满活力的集市。很好的比喻。&lt;/li&gt;
  &lt;li&gt;动态元编程和静态元编程，C++的template属于静态元编程。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;the-ruby-object-model&quot;&gt;The Ruby Object Model&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;Class定义永远是开放的，你能重新定义任何类或者给类加上一些新的东西。注意MonkeyPatch可能导致的Bug。&lt;/li&gt;
  &lt;li&gt;分清楚instance_method和class_method，&lt;/li&gt;
  &lt;li&gt;&lt;img src=&quot;/images/instance_method.png&quot; alt=&quot;instance_method&quot; class=&quot;img-center&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;Class也是对象。与C#/Java的Class不一样的地方，Ruby允许在代码运行期间操作类相关的信息，比如增加method或者重新定义method。&lt;/li&gt;
  &lt;li&gt;&lt;img src=&quot;/images/object_model.png&quot; alt=&quot;object_model&quot; class=&quot;img-center&quot; /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;methods&quot;&gt;Methods&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;static type checking, for example, if you call simple_talk() on Layer object that has no such method, the compiler protests loudly. &lt;/li&gt;
  &lt;li&gt;call method dynamic using send().&lt;/li&gt;
  &lt;li&gt;define_method generates instance method dynamically, to_s vs to_sym.&lt;/li&gt;
  &lt;li&gt;Ghost method, method_missing.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;过多是用会不会拖慢执行效率，要顺着继承链一直查找method。&lt;/p&gt;

  &lt;p&gt;注意method_missing可能导致的死循环调用。&lt;/p&gt;

  &lt;p&gt;和继承过来的method之间的冲突， undef_method解决。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;blocks&quot;&gt;Blocks&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;class, module, and def change scope.&lt;/li&gt;
  &lt;li&gt;Flat Scope.&lt;/li&gt;
  &lt;li&gt;instacen_eval/instance_exec&lt;/li&gt;
  &lt;li&gt;create block : lambda/proc/Proc.new&lt;/li&gt;
  &lt;li&gt;lambda vs Proc&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;return in Proc also return from the scope.&lt;/p&gt;

  &lt;p&gt;lambda’s argument checking is more strict.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;A event DSL, a elegent example for blocks.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;class-definitions&quot;&gt;Class Definitions&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;A Ruby class definition is actually regular code that runs.&lt;/li&gt;
  &lt;li&gt;class_eval vs instance_eval&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;class_eval both changes self and current class&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;Eigenclass, the metaclass of a object &lt;/li&gt;
    &lt;li&gt;three way to define class method&lt;/li&gt;
    &lt;li&gt;Around alias&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;code-writes-code&quot;&gt;Code writes code&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;The powerful weapon: eval&lt;/li&gt;
  &lt;li&gt;A good example: add_attribute&lt;/li&gt;
  &lt;li&gt;Three ways to express this idea&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;active-record&quot;&gt;Active record&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Validations&lt;/li&gt;
  &lt;li&gt;alias_method_chain&lt;/li&gt;
  &lt;li&gt;Dynamic attributes, define read/write/question Dynamic Methods for all the columns in databases, for performance.&lt;/li&gt;
  &lt;li&gt;Lesson learned, performance/complexity/readable trade-offs.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;metaprogramming-safely&quot;&gt;Metaprogramming safely&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Defusing Monkeypatches, make it explicit with module, check it before patche, add warning messages.&lt;/li&gt;
&lt;/ul&gt;

</description>
				<published>2013-07-07 00:00:00 +0800</published>
				<link>http://cyukang.com/2013/07/07/meta-programming-ruby.html</link>
			</item>
		
			<item>
				<title>初学Rails</title>
				<description>
&lt;p&gt;我在2012年左右开始关注Ruby，平时有的时候会用Ruby写一些脚本。这是一个很活跃的社区，Ruby火起来也不是最近的事。可贵的这里总是有一些新的东西出来，比如我现在的这个博客是基于jekyll和Github的。
Ruby的迅速崛起更多的还是因为Rails，所以学习Rails也是了解Ruby的一个好方法。&lt;/p&gt;

&lt;p&gt;最近为公司内部所配置的GitLab是Rails开发的。另外我自己也在公司做一些Web程序，其实是很简单的东西，就是把每天晚上跑的程序各种测试结果展示出来(nightly/weekly/coverage等等)。我选用Rails来开发，果然一个最初的版本很快就做出来了。在初学Rails的过程中让我体会到了一些web开发的乐趣。&lt;/p&gt;

&lt;p&gt;Rails适合小团队的快速开发，其中的一些理念是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Encourage Agility             --鼓励敏捷开发 &lt;/li&gt;
&lt;li&gt;Convention Over Configuration --约定高于配置 &lt;/li&gt;
&lt;li&gt;DRY                           --不要重复自己 &lt;/li&gt;
&lt;li&gt;Less Code                     --更短小的代码 &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;正是这些开发原则使得Rails开发如此简单明了(当然前提是你按照Rails约定的方式来)。
我原来做过一些web开发服务器方面的工作，在那种模式下开发需要每个人各司其责。
但是Rails不同，在ActiveRecord这样的抽象层基础上你需要关注的数据库方面的东西少了，
明确的MVC模式把你需要关注的撤离开来，这种复杂程度一个人完全能掌控下来。当然这种高度的抽象是以牺牲一部分效率为前提的，但其实在很多时候开发效率的优先级是高于实现效率的，
这也是Ruby所选择的一个理念。 &lt;/p&gt;

&lt;p&gt;学习Rails的过程中这些资料是非常好的，这几本书都面向初学者，写得非常详细：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://railstutorial-china.org/&quot;&gt;Ruby On Rails教程&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://book.douban.com/subject/4005707/&quot;&gt;Begining Rails 3&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://book.douban.com/subject/1416743/&quot;&gt;Agile Web Development with Rails&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当我熟悉了一些基本概念的时候，我就可以看Github上各种Rails的代码了，约定高于配置的另外一个优点就是所有Rails开发的东西结构看起来是一样的，便于不同开发者之间的交流。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Rails的一个比较突出的问题是版本之间的兼容性比较差。&lt;/p&gt;

&lt;p&gt;比如Begining Rails里面Plugin那章的那个例子，在Rails3.1系列开始已经不支持那种方式的plugin了，其中用到的&lt;a href=&quot;http://stackoverflow.com/questions/12313621/undefined-method-class-inheritable-accessor-for-activerecordextensionssqlite&quot;&gt;class_inheritable_accessor&lt;/a&gt;也变成了class_attribute。这种问题非常多，另外据说最新的Rails4.0改动也很大。&lt;/p&gt;

&lt;p&gt;这是一个老问题，在早起的版本就有人在这上面都发生过争吵。一些人说变化太频繁，不容易学习。
其中这篇&lt;a href=&quot;http://erniemiller.org/2011/06/14/wth-is-happening-to-rails-ill-tell-you/&quot;&gt;“WTH is happening to Rails?” I’ll tell you&lt;/a&gt; 
解释了一下Rails如此的原因，并称这种改变位『成长』。&lt;/p&gt;

&lt;p&gt;学习Rails的路还比较长，后面继续。&lt;/p&gt;

</description>
				<published>2013-07-06 00:00:00 +0800</published>
				<link>http://cyukang.com/2013/07/06/studying-rails.html</link>
			</item>
		
			<item>
				<title>高效的Crit-bit Tree</title>
				<description>
&lt;p&gt;最近了解到有这么一种数据结构，想拿来在工作中做一些事情，结果效果不好。原来我的理解有一些不对。在这里记录一下。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://cr.yp.to/critbit.html&quot;&gt;Crit-bit tree&lt;/a&gt;是一种特别的树结构，一般用于存放字符串。Critbit tree是一种&lt;a href=&quot;http://en.wikipedia.org/wiki/Trie#Bitwise_tries&quot;&gt;BitWise tries&lt;/a&gt;，其树的深度为O(longest-length)，有点像二叉树，不过对于字符串做分支检测的时候代价很小。&lt;/p&gt;

&lt;p&gt;Crit-bit快速高效的支持下面的一些操作：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;插入一个字符串&lt;/li&gt;
  &lt;li&gt;测试一个字符串是否在树里&lt;/li&gt;
  &lt;li&gt;删除一个字符串&lt;/li&gt;
  &lt;li&gt;查找出树中所有以某个字符串开始的所有字符串&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;和hash有点像，不过hash对于第四点没这么方便。
我做了一些性能对比，测试数据是&lt;code&gt;/usr/share/dict/words&lt;/code&gt;里面的所有单词，同时做插入和查询的操作。具体测试代码看&lt;a href=&quot;https://github.com/chenyukang/critbit-perf&quot;&gt;这里&lt;/a&gt;，结果是：&lt;/p&gt;

&lt;table border=&quot;2&quot; cellpadding=&quot;5&quot; align=&quot;center&quot;&gt;
  &lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;critbit &lt;/td&gt; &lt;td&gt; 11.6 MB&lt;/td&gt; &lt;td&gt;  23.34s &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;set &lt;/td&gt;    &lt;td&gt;21.6 MB&lt;/td&gt;&lt;td&gt;   45.85s&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;trie &lt;/td&gt;   &lt;td&gt;332.3 MB&lt;/td&gt; &lt;td&gt; 17.84s&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;从中可以看到trie树的内存消耗是比较大的，但是查找速度最好。critbit的内存消耗真的非常小，如果只是把这里所有的单词存下来都要4MB的内存，其查找的速度虽然和trie树比起来差一些，但还是相当不错。&lt;/p&gt;

&lt;p&gt;好好的研读了crit-bit的实现和这篇文章，里面技巧挺多的。
critbit的结构很简单:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;child&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;uint32&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;uint8&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;otherbits&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;critbit0_node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;critbit0_tree&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;其中child是void*指针，对于树的内部节点其指向的是子节点，对于叶子节点其指向的是字符串。
byte用来表示当前节点匹配的长度，otherbits是一个mask，可以用来快速的取得不同最高位，在查询的过程中用这个来做branch。&lt;/p&gt;

&lt;p&gt;具体的代码分析这里比较少，最复杂的函数是critbit0_insert。在插入过程中需要记录下来byte和otherbits,
并且更新前面的父节点。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/critbit.png&quot; alt=&quot;critbit&quot; class=&quot;img-center&quot; height=&quot;400&quot; width=&quot;400&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然后再继续插入后的结构变化是:
&lt;img src=&quot;/images/critbit_insert.png&quot; alt=&quot;critbit&quot; class=&quot;img-center&quot; height=&quot;400&quot; width=&quot;400&quot; /&gt;&lt;/p&gt;

&lt;p&gt;下面记录一下其中的几个技巧。&lt;/p&gt;

&lt;h4 id=&quot;align&quot;&gt;align指针最后一位用来做标志&lt;/h4&gt;

&lt;p&gt;树的结构需要一个标志变量来表示是否是内部节点或者是叶子节点。这个变量如何能省掉？
看上面的void* root和void* child, 都是即可以用来指向字符串又可以指向节点，一般申请过来的指针变量都是align好的，所以最低位为0，这是可以拿来用的。因此对于内部节点我们可以在这个位上设置为1，只是要注意在通过这个指针取值的时候需要减回去。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;a = (posix_memalign((void**)&amp;amp;x, sizeof(void*), ulen+1))&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;posix_memalign在这里用的是sizeof(void*)，其实就和malloc一样了，因为一般Linux上编译器和C库已经处理了对齐问题。&lt;/p&gt;

&lt;p&gt;因此在查找的这段代码里是这样的：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;critbit0_contains&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;critbit0_tree&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uint8&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ubytes&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ulen&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;strlen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;uint8&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;intptr_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;       &lt;span class=&quot;c1&quot;&gt;//内部节点? &lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;critbit0_node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//取得真正的指针&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;uint8&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;byte&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ulen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ubytes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;direction&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;otherbits&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;child&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;direction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;//叶子节点&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;strcmp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h4 id=&quot;bit&quot;&gt;取最高位的非0bit&lt;/h4&gt;

&lt;p&gt;在插入过程中计算最高位的不同位。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;newotherbits = p[newbyte]^ubytes[newbyte];&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;其实也可以用一个for循环来计算，不过这里是这样实现的:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;&lt;span class=&quot;n&quot;&gt;newotherbits&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newotherbits&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;newotherbits&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newotherbits&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;newotherbits&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newotherbits&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这相当于是计算不小于它的2的整数次幂，对于32bit的代码可以看看&lt;a href=&quot;http://blog.codingnow.com/cloud/CodeCollection&quot;&gt;这里&lt;/a&gt;的&lt;code&gt;next_pow_of_2&lt;/code&gt;。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/agl/critbit&quot;&gt;文章和代码&lt;/a&gt;，其中那篇文章有详细分析。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/chenyukang/critbit-perf&quot;&gt;我的测试代码,trie/set等&lt;/a&gt;。 &lt;/p&gt;
</description>
				<published>2013-05-18 00:00:00 +0800</published>
				<link>http://cyukang.com/2013/05/18/critbit.html</link>
			</item>
		
			<item>
				<title>迁移到Git</title>
				<description>
&lt;p&gt;公司这群人终于打算从CVS迁徙到Git上了，CVS这套公司用了六年。CVS这是90年代的东西，我们不能因为年代久远而嫌弃这，只是CVS这东西对于一个比较大的项目来说创建分支是相当漫长，大多数程序员都没有耐心的。
迁徙计划虽然纸上谈兵了很长时间，直到现在才终于打算行动。&lt;/p&gt;

&lt;p&gt;上午把Git在服务器上搭建好，主要卡在一个Git的命令上，因为一些权限问题。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;git init --bare --shared&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;group ; --shared&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;group forget this
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Git的web接口是用的是&lt;a href=&quot;http://viewgit.fealdia.org/&quot;&gt;ViewGit&lt;/a&gt;，自己做了一些修改，加上&lt;a href=&quot;http://qbnz.com/highlighter/&quot;&gt;GeShi&lt;/a&gt;来高亮代码，并使用了&lt;a href=&quot;https://github.com/trybeee/GitStats&quot;&gt;GitStats&lt;/a&gt;来做代码统计。GitStats统计的项目非常多，看起来很直观。&lt;/p&gt;

&lt;p&gt;稍微记录一下常用的一些git命令。&lt;/p&gt;

&lt;p&gt;这里有一个最直观的Git学习的地方&lt;a href=&quot;http://pcottle.github.io/learnGitBranching/?demo&quot;&gt;leanGitBranch&lt;/a&gt;。&lt;/p&gt;

&lt;table border=&quot;2&quot; cellpadding=&quot;5&quot; align=&quot;center&quot;&gt;
  &lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;检出仓库 &lt;/td&gt; &lt;td&gt;   git clone repo&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; 更新&lt;/td&gt;   &lt;td&gt; git pull&lt;/td&gt;
&lt;tr&gt;
&lt;td&gt; 提交到远程&lt;/td&gt; &lt;td&gt; git push&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;提交到本地&lt;/td&gt;  &lt;td&gt;git commit -am&quot;log message&quot; &lt;/td&gt;
&lt;/tr&gt;
&lt;td&gt;创建branch&lt;/td&gt;  &lt;td&gt;git branch branch_name&lt;/td&gt;
&lt;tr&gt;
&lt;td&gt;切换branch&lt;/td&gt;  &lt;td&gt;git checkout branch_name&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;合并branch&lt;/td&gt;  &lt;td&gt;git merge branch_name&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;图形界面&lt;/td&gt;         &lt;td&gt; gitk&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;解决冲突&lt;/td&gt;          &lt;td&gt;git mergetool&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;撤销上一次commit&lt;/td&gt;  &lt;td&gt;git revert HEAD&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;撤销上上次commit&lt;/td&gt;  &lt;td&gt;git revert HEAD^ &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;撤销上一次的merge&lt;/td&gt;  &lt;td&gt;git reset --hard HEAD^&lt;/td&gt;
&lt;/tr&gt;




&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
</description>
				<published>2013-05-09 00:00:00 +0800</published>
				<link>http://cyukang.com/2013/05/09/git-command.html</link>
			</item>
		
			<item>
				<title>看看Lua 1.0 代码</title>
				<description>
&lt;p&gt;最近稍微看了一些Lua方面的东西，当前的实现是5.2版本的，代码也才2w来行。不过偶然下载了1.0版本的代码，发现更精简。Lua的设计原则一直坚持着，
作者甚至在OO盛行的年代也没有给Lua加上原生的class和object概念。这个版本虽然简陋，但还是可以稍微看看来体会Lua的设计原则，也为阅读最新的Lua代码做个预热。&lt;/p&gt;

&lt;p&gt;首先来看看Lua1.0的一些基本情况：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; The implementation followed a tenet that is now central to Extreme Programming: 
 “the simplest thing that could possibly work” . 
 The lexical scanner was written with lex and the parser with yacc, 
 The parser translated Lua programs into instructions for a stack-based 
 virtual machine, which were then executed by a simple interpreter. 
 
 Despite this simple implementation — or possibly because of it — 
 Lua surpassed our expectations.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里的主要内容包含两个部分：stack based虚拟机，lex/yacc语法分析。&lt;/p&gt;

&lt;p&gt;y_tab.c这个文件主要功能是语法分析，工具yacc生成的代码，没什么可读性。或者应该找文件lua.stx来看看，不过这个文件并没有被包含在1.0的代码里。&lt;/p&gt;

&lt;p&gt;当执行&lt;code&gt;./lua array.lua&lt;/code&gt;类似代码的时候，首先打开文件array.lua，把io读写设置为文件读写，然后这段代码开始parse生成指令并运行。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;lua_parse&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Byte&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;initcode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;maincode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;yyparse&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;maincode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HALT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lua_execute&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;initcode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;maincode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;initcode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;stack-based的虚拟机用来执行生成的虚拟指令，最重要的几个变量是pc指向当前运行的指令(也可能是数据)，top指向执行栈的顶部，base指向栈的底部。指令分为几类，Push/Store，跳转类(JMP, ONTJMP, ONFJMP,IFFJMP) 运算类(+,-,*,/ 等等)，还有和函数调用相关的(CALLFUNC,RETCODE)。
top往下的几个指针指向的是最近计算需要的变量，而结果也往往是放在栈的顶部，最简单的四则运算执行过程如下：
&lt;img src=&quot;/images/two_op.png&quot; alt=&quot;My code is compiling&quot; class=&quot;img-center&quot; /&gt;
另外有一些只要一个Op的指令也类似，不过不会把top往下移动。 &lt;/p&gt;

&lt;p&gt;Lua的代码风格很好，很值得学习，一些人已经在写一些源码分析方面的书籍了，比如云风的这个系列&lt;a href=&quot;http://www.codingnow.com/temp/readinglua.pdf&quot;&gt;Reading Lua&lt;/a&gt;，还有这个&lt;a href=&quot;http://www.codedump.info/?tag=lua&quot;&gt;系列&lt;/a&gt;。再挖一个坑，以后花时间好好研读新的Lua代码。我快从原来挖的那个坑里走出来了，一个Hobby OS至少可以运行了， :)。&lt;/p&gt;

&lt;p&gt;另外如果你对实现一个小语言感兴趣，&lt;a href=&quot;http://www.ruby-forum.com/topic/121846#545361&quot;&gt;这里Ruby quiz #135有一个使用虚拟机实现的方式&lt;/a&gt;。&lt;/p&gt;
</description>
				<published>2013-04-17 00:00:00 +0800</published>
				<link>http://cyukang.com/2013/04/17/lua_10_source.html</link>
			</item>
		
			<item>
				<title>一些包管理命令</title>
				<description>
&lt;p&gt;包管理器是Linux上一个经常用的东西，我觉得下面这几个命令是非常有用的，便于查询包的状态，或者搜索我该安装哪些包。&lt;/p&gt;

&lt;h2 id=&quot;apt-cache&quot;&gt;apt-cache&lt;/h2&gt;

&lt;p&gt;用来根据名字查询软件包，比如apt-cache search vim查询vim相关的。&lt;/p&gt;

&lt;h2 id=&quot;apt-file&quot;&gt;apt-file&lt;/h2&gt;

&lt;p&gt;用来根据某个文件查询软件包，这在编译程序的时候非常有用，可以通过所需要的头文件去查询要安装的东西，可以避免去Google了。注意使用之前需要安装并update。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install apt-file
sudo apt-file update
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;比如我在编译某个软件的时候找不到&amp;lt;readline/readline.h&amp;gt;，使用下面的命令来查询一下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-file readline.h
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果中有这么一行，那么我就知道继续安装libreadline5-dev库就行了。&lt;/p&gt;

&lt;h2 id=&quot;dpkg&quot;&gt;dpkg&lt;/h2&gt;

&lt;p&gt;apt是基于dpkg开发的，dpkg是更古老更底层的一套工具，Debian系统管理器的基础。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dpkg -l 列出所有已经安装的包
dpkg -s vim 列出包vim的状态
dpkg -L vim 列出本地所有vim相关联系的文件
dpkg -S vim 搜索所属包的内容
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;brew&quot;&gt;brew&lt;/h2&gt;

&lt;p&gt;Mac下推荐Brew来替代apt，大部分的开源包都有对应的地址源了。我没使用过MacPorts，无法比较这两套的差别。
不过我个人很喜欢的一点是brew所有安装的东西都在&lt;code&gt;brew -prefix&lt;/code&gt;/Cellar这个统一目录下，&lt;/p&gt;

&lt;p&gt;brew相关的命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;brew list   — 列出已安装的软件
brew update — 更新Homebrew
brew home   — 用浏览器打开
brew info   — 显示软件内容信息
brew deps   - 显示包依赖
&lt;/code&gt;&lt;/pre&gt;

</description>
				<published>2013-04-17 00:00:00 +0800</published>
				<link>http://cyukang.com/2013/04/17/apt-usage.html</link>
			</item>
		
			<item>
				<title>巧妙的XOR Link List</title>
				<description>
&lt;p&gt;XOR Link List, 只用一个附加的变量来实现双向链表。首先xor本身是个稍微有点难理解的操作。xor有下面的一些特性:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;A ^ 0 = A&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;A ^ A = 0&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;A ^ B = B ^ A&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;(A ^ B) ^ A = B&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;(B ^ A) ^ B = A&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;注意最后两条，这是XOR Link List的关键，这也是通过xor操作来实现swap的关键。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;xorSwap&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
         &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;^=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
         &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;^=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
         &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;^=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
     &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这里注意需要判断x!=y，否则如果传入的是相同的指针，最后所指向的变量被设置为0了。&lt;/p&gt;

&lt;p&gt;通过最后两条联想到双向链表中的两个指针的实现，一般如下图所示：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;      &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;       &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt;         &lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;         &lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;         &lt;span class=&quot;n&quot;&gt;E&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
               &lt;span class=&quot;err&quot;&gt;–&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;–&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;  &lt;span class=&quot;err&quot;&gt;–&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;  &lt;span class=&quot;err&quot;&gt;–&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;        
               &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;–&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;–&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;–&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;–&lt;/span&gt;        
 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果把next和prev用一个变量替换还能实现前向和后向遍历，那就节省了一个变量的空间。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt;         &lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;         &lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;         &lt;span class=&quot;n&quot;&gt;E&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;–&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;⊕&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;&amp;lt;-&amp;gt;&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;⊕&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;&amp;lt;-&amp;gt;&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;⊕&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;E&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;&amp;lt;-&amp;gt;&lt;/span&gt;
 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;比如当前在B节点，其pointer变量为A⊕C，如果前面的A地址保存下来然后做运算(A⊕C)⊕A -&amp;gt; C，这样就得到下一个节点指针，反向遍历同样如此。当然其缺点是逻辑复杂了，删除其中的某一个节点也不方便(删除头和尾要好点)，遍历的时候需要保存上一个节点。这样看来为了省一点点空间这样实现似乎有点不值，在大部分情况下这样的一个pointer的节省并没什么用，不过这其中的细节有趣、巧妙。&lt;/p&gt;

&lt;p&gt;同样上面的xorSwap&lt;a href=&quot;http://stackoverflow.com/questions/249423/how-does-xor-variable-swapping-work&quot;&gt;对于现代的CPU来说也没什么优化&lt;/a&gt;，这样的代码只是更加不便于编译器来实现指令级别的优化。这种类型trick的东西还是要避免使用才好。&lt;/p&gt;

&lt;p&gt;自己稍微写了一下，代码在&lt;a href=&quot;https://gist.github.com/chenyukang/5364515&quot;&gt;这个Gist&lt;/a&gt;。&lt;/p&gt;
</description>
				<published>2013-04-11 00:00:00 +0800</published>
				<link>http://cyukang.com/2013/04/11/xor_link_list.html</link>
			</item>
		
			<item>
				<title>Jekyll使用MathJax来显示数学式</title>
				<description>
&lt;p&gt;使用Jekyll写作文章的时候有可能需要内嵌一些数学公式, &lt;a href=&quot;http://www.mathjax.org/&quot;&gt;MathJax&lt;/a&gt;就是用来干这个的，试用了一下感觉非常方便。步骤如下:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;修改html头部。&lt;/p&gt;

    &lt;p&gt;在每个页面开头加上这么一句，在Jekyll下可以通过修改default.html加上。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;script&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;text/javascript&amp;quot;&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;script&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;本地安装kramdown。&lt;/p&gt;

    &lt;p&gt;因为rdiscount和默认的markdown在解析带公式文件的时候都会出现&lt;a href=&quot;http://stackoverflow.com/questions/10987992/using-mathjax-with-jekyll&quot;&gt;一些问题&lt;/a&gt;，所以最简单办法还是安装kramdown。
 ` $ gem install kramdown`&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;修改_config.yml，把markdown选项修改为:&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;markdown: kramdown&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;然后在发布的时候就可以使用&lt;code&gt;$$&lt;/code&gt;来把需要显示的数学式子扩起来。像这样：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$$a^2 + b^2 = c^2$$&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;发布出来就是漂亮的公式了。
    &lt;script type=&quot;math/tex&quot;&gt;a^2 + b^2 = c^2&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;一些更酷的例子：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt; J_\alpha(x) = \sum\limits_{m=0}^\infty \frac{(-1)^m}{m! \, \Gamma(m + \alpha + 1)}{\left({\frac{x}{2}}\right)}^{2 m + \alpha} &lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt; \frac{1}{\Bigl(\sqrt{\phi \sqrt{5}}-\phi\Bigr) e^{\frac25 \pi}} =
1+\frac{e^{-2\pi}} {1+\frac{e^{-4\pi}} {1+\frac{e^{-6\pi}}
{1+\frac{e^{-8\pi}} {1+\ldots} } } } &lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt; \left( \sum_{k=1}^n a_k b_k \right)^2 \leq \left( \sum_{k=1}^n a_k^2 \right) \left( \sum_{k=1}^n b_k^2 \right)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt; 
\begin{aligned}
\nabla \times \vec{\mathbf{B}} -\, \frac1c\, \frac{\partial\vec{\mathbf{E}}}{\partial t} = \frac{4\pi}{c}\vec{\mathbf{j}} \\ \nabla \cdot \vec{\mathbf{E}} = 4 \pi \rho \\
\nabla \times \vec{\mathbf{E}}\, +\, \frac1c\, \frac{\partial\vec{\mathbf{B}}}{\partial t} = \vec{\mathbf{0}} \\
\nabla \cdot \vec{\mathbf{B}} = 0 \end{aligned}
&lt;/script&gt;

&lt;p&gt;不过我可能永远用不到这么复杂的表达式 :). &lt;/p&gt;

&lt;p&gt;另外今天找了一个&lt;a href=&quot;http://jblevins.org/projects/markdown-mode/&quot;&gt;markdown-mode.el&lt;/a&gt;，在Emacs下编辑Markdown文件又方便了不少。
   Mac下的Markdown编辑器&lt;a href=&quot;http://mouapp.com/&quot;&gt;Mou&lt;/a&gt;也是非常不错的。&lt;/p&gt;

</description>
				<published>2013-03-03 00:00:00 +0800</published>
				<link>http://cyukang.com/2013/03/03/try-mathjax.html</link>
			</item>
		
			<item>
				<title>读bootstrap scheme</title>
				<description>
&lt;p&gt;&lt;img src=&quot;/images/scheme_car_cdr.png&quot; alt=&quot;scheme-car-cdr&quot; class=&quot;img-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;For a List in Lisp, Car is the First, Cdr is the Rest, and Lisp means List-Proccessing.&lt;/p&gt;

&lt;p&gt;前段时间偶然在网上看到这个&lt;a href=&quot;https://github.com/petermichaux/bootstrap-scheme&quot;&gt;bootstrap scheme这个开源程序&lt;/a&gt;，读来简洁明了，十分有趣。我对scheme有一点了解，毕竟以前看过一段时间SICP，自己做练习的代码也是scheme写的。scheme本身属于Lisp方言，语法也极其简单，学习起来非常快的。&lt;/p&gt;

&lt;p&gt;看看这个简单的scheme实现，不禁再次感叹递归的优美。Lisp这样的语言直接使用语法树结构来表示程序，不仅使得表示出来的程序异常简洁，就是用C语言来实现这种语言的解释器代码也看起来非常优美。在这里区区2000行的C语言代码，当然没有完整地实现scheme所有的内容，甚至只支持了整数。但是包含scheme的基本语法层面的东西，还有lambda。抛开实现的效率不说，递归是易于编写和理解代码的一种方式，这里语法是递归的，parser是递归的，eval也是递归的。在这里所有的东西都是object，没有显示的列表结构，但是嵌套的pair里蕴含着列表和树的关系。在parse阶段建立好一个以object为基本元素的树结构，做eval的时候顺着往下走就是了。&lt;/p&gt;

&lt;p&gt;推荐对语言实现感兴趣的同学阅读一下这个代码，如果对scheme不了解也没关系，用一个小时看几个scheme程序基本就了解了。再看这个解释器，你就懂了代码是如何被运行的。&lt;/p&gt;

&lt;p&gt;参考&lt;a href=&quot;http://peter.michaux.ca/articles/scheme-from-scratch-introduction&quot;&gt;scheme-from-scratch-introduction&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;图片来自&lt;a href=&quot;http://www.cs.utah.edu/~draperg/cartoons/&quot;&gt;Draperg’s cartoons&lt;/a&gt;&lt;/p&gt;
</description>
				<published>2013-02-15 00:00:00 +0800</published>
				<link>http://cyukang.com/2013/02/15/reading-bootstrap-scheme.html</link>
			</item>
		
	</channel>
</rss>
